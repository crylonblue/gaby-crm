import { sqliteTable, text, integer, real } from "drizzle-orm/sqlite-core";

export const customers = sqliteTable("customers", {
    id: integer("id").primaryKey({ autoIncrement: true }),
    lastName: text("last_name").notNull(),
    firstName: text("first_name").notNull(),
    birthDate: text("birth_date"),
    mobilePhone: text("mobile_phone"),
    landlinePhone: text("landline_phone"),
    street: text("street"),
    houseNumber: text("house_number"),
    postalCode: text("postal_code"),
    city: text("city"),
    insuranceNumber: text("insurance_number"),
    healthInsurance: text("health_insurance"),
    healthInsurancePhone: text("health_insurance_phone"),
    healthInsuranceEmail: text("health_insurance_email"),
    careLevel: text("care_level"), // 1-5
    email: text("email"),
    notes: text("notes"),
    abtretungserklaerungUrl: text("abtretungserklaerung_url"),
});

export const invoices = sqliteTable("invoices", {
    id: integer("id").primaryKey({ autoIncrement: true }),
    customerId: integer("customer_id").notNull(), // Foreign key relation manually handled or just stored
    status: text("status").notNull().default("processing"), // processing, in_delivery, sent, aborted
    date: text("date").notNull(),
    invoiceNumber: text("invoice_number"), // Can be null initially if generated by worker, or auto-generated here

    // Snapshot of Customer Data
    lastName: text("last_name").notNull(),
    firstName: text("first_name").notNull(),
    healthInsurance: text("health_insurance"),
    insuranceNumber: text("insurance_number"),
    birthDate: text("birth_date"),
    careLevel: text("care_level"),

    street: text("street"),
    houseNumber: text("house_number"),
    postalCode: text("postal_code"),
    city: text("city"),
    invoiceEmail: text("invoice_email"),

    // Invoice Data
    hours: real("hours").notNull(), // Storing as number/real might be better if floating point needed? Drizzle sqlite integer mode number is usually int. 
    // SQLite stores numbers as REAL or INTEGER. Drizzle 'integer' with mode 'number' handles JS numbers.
    // BUT for 1.5 hours, integer might truncate? 
    // Better update to `real` for hours and costs.
    description: text("description").notNull(),
    ratePerHour: real("rate_per_hour").notNull().default(47.0), // Storing in cents? User said "47€". 
    // Let's store as Text or Real to avoid float math issues, or cents. 
    // Simplest for now: Real/Text. User asked for "47€", usually best to store as cents (4700). 
    // Let's use REAL for simplicity with "0,30€" -> 0.30.

    km: real("km").notNull().default(0),
    ratePerKm: real("rate_per_km").notNull().default(0.30), // 0.30€ -> 30 cents?

    // Let's stick to REAL for simplicity with the "0.25" steps in the form.
    // sqlite `real` maps to JS number.

    createdAt: text("created_at").notNull(), // ISO String
    invoicePdfUrl: text("invoice_pdf_url"), // URL provided by worker
    abtretungserklaerungUrl: text("abtretungserklaerung_url"),
    sendEmailAutomatically: integer("send_email_automatically", { mode: "boolean" }).notNull().default(true), // Whether to send email automatically
});

export const customerBudgets = sqliteTable("customer_budgets", {
    id: integer("id").primaryKey({ autoIncrement: true }),
    customerId: integer("customer_id").notNull(),
    year: integer("year").notNull(),
    amount: real("amount").notNull().default(0),
});

export type Customer = typeof customers.$inferSelect;
export type NewCustomer = typeof customers.$inferInsert;

export type Invoice = typeof invoices.$inferSelect;
export type NewInvoice = typeof invoices.$inferInsert;

export type CustomerBudget = typeof customerBudgets.$inferSelect;
export type NewCustomerBudget = typeof customerBudgets.$inferInsert;

